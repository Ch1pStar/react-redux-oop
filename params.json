{
  "name": "React-Redux OOP",
  "tagline": "OOP implementation of redux and react.",
  "body": "# react-redux-oop\r\n\r\nOOP implementation of redux and react.\r\n\r\n## Motivation\r\n\r\nFunctional programming is very popular right now among web and mobile frontend developers. It's a cool way of doing things but in my opinion it's never black and white. It's a good paradigm and developers can learn a hell lot out of it but I personally don't like they apps are being organized. I just like many developers don't like plain functions in hundreds lowercase files. I like the class structure, because it eases reading and understanding the code a lot. I believe this implementation of redux and react can be helpful for bigger applications.\r\n\r\n## Installation\r\n\r\n`npm install --save react-redux-oop`\r\n\r\nThe UMD build is in the dist directory.\r\n\r\n## Description\r\n\r\nThis is just an implementation of react and redux. It uses plain `react`, `redux` and `react-redux`.  No functionality is changed or added to these libraries. It's only a way to organize your app with a bunch of helpful classes. Also it solves the problem with multiple stores and binded action creators.\r\n\r\n#### Store\r\n\r\nThis is a wrapper of the redux store. It's purpose is to be able to easily enable and disable reducers without too much function composition. Also **splits reducers by actions and store path**, instead of just store path. The store requires the usage of [seamless-immutable](https://github.com/rtfeldman/seamless-immutable). It will automatically force it onto your state objects. It also extends [eventemitter3](https://github.com/primus/eventemitter3).\r\n\r\n```typescript\r\nclass Store extends EventEmitter {\r\n    constructor(state: Object, enhancer: function) {}\r\n    \r\n    addReducer(action: string, path: string, reducer: function) {}\r\n    removeReducer(action: string, path: string, reducer: function) {}\r\n    addReducers(reducers: Object) {}\r\n    removeReducers(reducers: Object) {}\r\n    \r\n    get state(): Object {}\r\n    get reduxStore(): Object {}\r\n}\r\n```\r\n\r\n##### Reducers\r\n\r\nReducers in the Store are added either as a single reducer or as an object of this format:\r\n\r\n```javascript\r\nstore.addReducers({\r\n    'ADD_ITEM': {\r\n        'todo': [\r\n            (state = {lastId: 0, items: {}}, action) => {\r\n                // Do the job\r\n            },\r\n            (state = {lastId: 0, items: {}}, action) => {\r\n                // Another reducer for the same action and state.\r\n            }\r\n        ]\r\n    },\r\n\r\n    'REMOVE_ITEM': {\r\n        'todo.items': [\r\n            (state = {}, action) => {\r\n                // Do the job\r\n            }\r\n        ]\r\n    },\r\n\r\n    // or you can use wildcards '*' meaning all actions or the full state:\r\n    '*': {\r\n        '*': [\r\n            (state = {}, action) => {\r\n                // Do the job\r\n            }\r\n        ]\r\n    }\r\n});\r\n```\r\n\r\n#### Controller\r\n\r\nThis \"abstract\" class is used to remove the need of action creators. **It combines dispatching with creating the action**. Every controller is provided with the store's dispatch. It also works on the server, because you can create multiple controllers with different stores. Action creators cannot be binded to the dispatch, because the store changes on the server and they are just functions, but controllers can, because they have context.\r\n\r\n```typescript\r\nclass Controller {\r\n    constructor(store: Object|Store) {}\r\n    \r\n    attachTo(store: Object|Store) {}\r\n    \r\n    dispatch(type: string, data: Object = {}) {}\r\n    getState(): Object {}\r\n    \r\n    get state(): Object {}\r\n}\r\n```\r\n\r\n#### Container\r\n\r\nThis is an \"abstract\" extension to the React.Component class. It uses react-redux to connect to the store but used a different syntax and flow to utilize the dispatch method. Every Container component can set an `actions` object of Controllers which are automatically provided with the store from react-redux'es Provider. **Containers are always treated as pure**.\r\n\r\n```typescript\r\nclass Container extends React.Component {\r\n    static connect() {}\r\n    constructor(props: Object) {}\r\n    dispatch(type: string, data: Object) {}\r\n}\r\n```\r\n\r\n#### App\r\n\r\n```typescript\r\nclass App {\r\n    constructor(state: Object = {}, middlewares: Array.<function> = [], enhancers: Array.<function> = []) {}\r\n    \r\n    configure(state: Object = {}) {}\r\n    renderTo(node: HTMLElement) {}\r\n    renderHtml() {}\r\n    renderStaticHtml() {}\r\n    \r\n    _addMiddleware(middleware, index = null) {}\r\n    _addEnhancer(enhancer: function, index: number = null) {}\r\n    _createStore(state:Object = {}) {}\r\n    _render() {}\r\n    \r\n    get store(): Store {}\r\n}\r\n```\r\n\r\nAn \"abstract\" facade class for your application. It's supposed to be extended with custom functionality. It only has a **bootstrapping function** and **may not be used at all** if you don't like it.\r\n\r\n\r\n## Example\r\n\r\nThere is a todo example in the example directory. It shows the full usage. Here is the basic idea:\r\n\r\n```javascript\r\nclass TodoController extends Controller {\r\n    addTodo(text) {\r\n        this.dispatch('ADD_TODO', {text});\r\n    }\r\n    \r\n    removeTodo() {\r\n        this.dispatch('ADD_TODO', {text});\r\n    }\r\n    \r\n    asyncAction() {\r\n        this.dispatch('ASYNC_START');\r\n        setTimeout(() => this.dispatch('ASYNC_COMPLETE'), 1000);\r\n    }\r\n}\r\n\r\nconst TodoReducers = {\r\n    'ADD_TODO': {\r\n        'todo': [\r\n            (state = {lastId: 0, items: {}}, action) => {\r\n                let newId = state.lastId + 1;\r\n\r\n                return {\r\n                    lastId: newId,\r\n                    items: state.items.merge({\r\n                        [newId]: {text: action.text, checked: false}\r\n                    })\r\n                }\r\n            }\r\n        ]\r\n    },\r\n\r\n    'REMOVE_TODO': {\r\n        'todo.items': [\r\n            (state = {}, action) => state.without(action.id)\r\n        ]\r\n    }\r\n}\r\n\r\nclass TodoContainer extends Container {\r\n    // This is mapStateToProps from react-redux\r\n    static mapper(state) {\r\n        return {\r\n            items: state.todo.items\r\n        };\r\n    }\r\n\r\n    // Actions can be defined this way:\r\n    actions = {\r\n        todo: new TodoController(),\r\n        another: new AnotherConroller();\r\n    }\r\n    \r\n    // or this way:\r\n    actions = new TodoController();\r\n\r\n    render() {\r\n        return (\r\n            <TodoList\r\n                items={this.props.items}\r\n                onAdd={text => this.actions.addTodo(text)}\r\n                onRemove={id => this.actions.removeTodo(id)}\r\n            />\r\n        );\r\n    }\r\n}\r\n\r\nTodoContainer = TodoContainer.connect();\r\n\r\n\r\nclass ExampleApp extends App {\r\n    constructor() {\r\n        super({\r\n            todo: {\r\n                lastId: 0,\r\n                items: {}\r\n            }\r\n        });\r\n\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            this._addMiddleware(require('redux-logger')());\r\n\r\n            let matches = window.location.href.match(/[?&]_debug=([^&]+)\\b/);\r\n            let session = (matches && matches.length) ? matches[1] : null;\r\n\r\n            let devTools = null;\r\n            if (window['devToolsExtension']) devTools = window['devToolsExtension']();\r\n\r\n            if (devTools) this._addEnhancer(devTools);\r\n        }\r\n    }\r\n\r\n    _render() {\r\n        return (\r\n            <div>\r\n                <TodoContainer />\r\n            </div>\r\n        );\r\n    };\r\n\r\n    _createStore() {\r\n        let store = super._createStore();\r\n        store.addReducers(TodoReducers);\r\n        return store;\r\n    }\r\n}\r\n\r\n\r\n// Create an app and append it to the DOM\r\n\r\nconst app = new ExampleApp();\r\n\r\napp\r\n  .configure({/* Change initial state, maybe from server or something. */})\r\n  .renderTo(document.getElementById('app'));\r\n\r\n// We can just create a controller and execute new actions.\r\n\r\nlet controller = new TodoController(app.store);\r\ncontroller.addItem('Have something to eat.');\r\ncontroller.addItem('Have something to drink.');\r\ncontroller.addItem('Sleep.');\r\n```",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}